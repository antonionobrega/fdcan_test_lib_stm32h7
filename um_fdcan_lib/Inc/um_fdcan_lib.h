/**
 * @file um_fdcan_lib.h
 * @brief Universal Messaging FDCAN Library
 * @author Antonio Nobrega
 * @date Sep 7, 2025
 *
 * @defgroup um_fdcan_lib FDCAN Messaging Library
 * @{
 *
 * @brief A high-level, thread-safe FDCAN communication library for STM32H7 devices
 *        using FreeRTOS and the STM32 HAL.
 *
 * @details This library provides a simplified, subscription-based API for sending and
 *          receiving CAN messages. It is designed to work on top of the configuration
 *          generated by STM32CubeIDE, abstracting away the low-level complexities of
 *          the FDCAN peripheral and HAL driver.
 *
 * ### Core Concepts
 * 1.  **Wrapper Object (`FDCAN_Wrapper_t`):** The library is organized around a "wrapper"
 *     or "manager" object. An instance of this object must be created for each FDCAN
 *     peripheral you intend to use (e.g., one for FDCAN1, another for FDCAN2). This
 *     object holds all the state, handles, and resources for that specific peripheral.
 *
 * 2.  **Global Wrapper Registry:** The library maintains a private, static global array of
 *     pointers to all initialized `FDCAN_Wrapper_t` instances. This is a crucial design
 *     element required to work with the STM32 HAL. The HAL FDCAN callbacks (like
 *     `HAL_FDCAN_RxFifo0Callback`) are generic and are not specific to a peripheral instance.
 *     When a callback is triggered, it only provides a `FDCAN_HandleTypeDef*`. The library
 *     uses this global array as a lookup table to find the corresponding `FDCAN_Wrapper_t`
 *     that owns that handle, allowing it to route the interrupt to the correct processing task.
 *
 * 3.  **Two-Layer Filtering (Hardware & Software):** The library uses a two-layer
 *     approach to efficiently handle messages.
 *
 *     -   **Layer 1: Hardware Filtering:** The user *must* first define hardware filters
 *         using the standard HAL `FDCAN_FilterTypeDef` structures and pass them to the
 *         `FDCAN_Wrapper_Init` function. This is the most critical step for performance.
 *         The FDCAN hardware will physically discard any message that does not match
 *         these filters, ensuring that the CPU is **never interrupted for irrelevant
 *         messages**. This dramatically reduces system load.
 *
 *     -   **Layer 2: Software Subscription:** After a message has passed the hardware
 *         filter, the library's software subscription model takes over. An application
 *         thread "subscribes" to a specific message ID using `FDCAN_Subscribe()`.
 *
 * 4.  **Opaque Handles for Subscriptions:** The `FDCAN_Subscribe()` function returns an
 *     `FDCAN_SubscriptionHandle_t`. This is an "opaque pointer" (or opaque handle).
 *     The application holds and uses this handle, but it cannot see the internal data
 *     structure it points to. This is a powerful software engineering concept that:
 *     -   **Prevents Bugs:** It stops the application from accidentally modifying the
 *         internal state of a subscription.
 *     -   **Simplifies the API:** The user only needs to manage this simple handle.
 *     -   **Improves Maintainability:** The library's internal subscription structure can
 *         be changed in the future without breaking any application code.
 *
 * 5.  **Blocking Receive with Queues:** Each subscription created via `FDCAN_Subscribe()`
 *     is backed by a dedicated FreeRTOS queue. The application thread can then call
 *     `FDCAN_Receive()` on its subscription handle. This function will block the thread
 *     (putting it into the FreeRTOS 'Blocked' state, consuming no CPU time) until a
 *     message with the subscribed ID arrives or a timeout occurs.
 *
 * ### Data Flow (Receiving a Message)
 * 1.  A CAN message arrives at the FDCAN peripheral.
 * 2.  The FDCAN hardware filters the message based on the rules configured during `FDCAN_Wrapper_Init`.
 * 3.  If the message passes the hardware filter, it is placed into the configured RX FIFO.
 * 4.  The hardware triggers a "New Message in FIFO" interrupt.
 * 5.  The HAL's interrupt handler (`HAL_FDCAN_IRQHandler`) is called, which in turn invokes the weak `HAL_FDCAN_RxFifoXCallback`.
 * 6.  **The library automatically overrides the weak HAL callback.** The library's implementation of the callback is executed.
 * 7.  Inside the callback, the library uses the **Global Wrapper Registry** to find which `FDCAN_Wrapper_t` instance corresponds to the interrupt source.
 * 8.  It then sends a lightweight notification to that wrapper's dedicated processing task via a central FreeRTOS queue. This keeps the time spent in the ISR to an absolute minimum.
 * 9.  The wrapper's processing task, which was pending on the queue, unblocks. It retrieves the full message from the FDCAN FIFO.
 * 10. It locks the subscription list and searches for a subscriber matching the message ID.
 * 11. If a match is found, it places the message data onto the specific queue associated with that subscription handle.
 * 12. The application thread, which was blocked on `FDCAN_Receive()`, unblocks as its queue now contains a message, and the function returns with the new data.
 *
 * @note This library is designed to be thread-safe. All access to shared resources,
 *       such as the subscription list, is protected by mutexes.
 */


 /* TODO LIST:
    *- Investigate priorities to avoid silent failures. There is a relation between the priorities of the tasks, the queue depth, and the interrupt priorities that can lead to lost messages if not set correctly.
    *- Handle other error statuses (Error Warning, Error Passive)
    *- I may have to play with the stack size of the internal thread (INTERNAL_THREAD_STACK_SIZE) if I start getting hard faults 
 */

#ifndef INC_UM_FDCAN_LIB_H_
#define INC_UM_FDCAN_LIB_H_

/* Includes -----------------------------------------------------------------------------------------------------------------------------------------------------------*/
#include "stm32h7xx_hal.h" // HAL library for stm32h7
#include "cmsis_os.h"     // Use CMSIS-OS v2 for RTOS objects
/* --------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#define INTERNAL_THREAD_PRIORITY      (osPriorityHigh)  // Priority for the internal processing thread
#define MAX_SUBSCRIPTIONS_PER_WRAPPER 15                // Max number of subscriptions per FDCAN wrapper instance
#define INTERNAL_THREAD_STACK_SIZE    (4 * 512)         // Stack size for the internal processing thread (2048 bytes)

#define MAX_FDCAN_INSTANCES         3                 // Maximum number of FDCAN peripherals supported (FDCAN1, FDCAN2, FDCAN3)
#define SUBSCRIBER_QUEUE_DEPTH      8                 // Depth of the queue for each individual subscriber

// Event flags for ISR-to-task signaling
// We use event flags instead of a queue because of the way both HAL FDCAN and the FDCAN peripheral work.
// The HAL FDCAN peripheral has sort of a buffer where they store all the incoming messages. 
// So the idea is that the ISR will just set a flag or signal for the internal thread to handle the reading and parsing of the messages
#define FDCAN_FLAG_RX_FIFO0                    (1U << 0)         // Flag for new message in RX FIFO 0
#define FDCAN_FLAG_RX_FIFO1                    (1U << 1)         // Flag for new message in RX FIFO 1

// Related to HAL_FDCAN_ErrorStatusCallback and FDCAN_Error_Status_Interrupts group in the documentation
#define FDCAN_FLAG_BUS_OFF                     (1U << 2)         // Flag for Bus Off event
#define FDCAN_FLAG_ERROR_WARNING               (1U << 3)         // Flag for Error Warning event
#define FDCAN_FLAG_ERROR_PASSIVE               (1U << 4)         // Flag for Error Passive event

// Related to HAL_FDCAN_ErrorCallback and FDCAN_Error_Interrupts group in the documentation
#define FDCAN_FLAG_ERROR_PROTOCOL_ARBITRATION  (1U << 5)         // Flag for Error Protocol Arbitration event
#define FDCAN_FLAG_ERROR_PROTOCOL_DATA         (1U << 6)         // Flag for Error Protocol Data Phase event
#define FDCAN_FLAG_ERRROR_RAM_ACCESS_FAILURE   (1U << 7)         // Flag for RAM Access Failure event
#define FDCAN_FLAG_ERROR_LOGGING_OVERFLOW      (1U << 8)         // Flag for Error Logging Overflow event
#define FDCAN_FLAG_RAM_WATCHDOG                (1U << 9)         // Flag for RAM Watchdog event
#define FDCAN_FLAG_RESERVED_ADDRESS_ACCESS     (1U << 10)        // Flag for Reserved Address Access event





/* Exported defines ----------------------------------------------------------------------------------------------------------------------------------------------------*/

/* Private defines ----------------------------------------------------------------------------------------------------------------------------------------------------*/
#define MAX_FDCAN_DATA_LENGTH           64 // Maximum FDCAN data length in bytes
#define MAX_FDCAN_CLASSICAL_DATA_LENGTH 8  // Maximum Classical CAN data length in bytes



/* Exported types -----------------------------------------------------------------------------------------------------------------------------------------------------*/

/**
 * @brief Structure to hold a complete FDCAN message.
 * This is the data type that is passed to/from the FDCAN_Receive function.
 */
typedef struct {
    FDCAN_RxHeaderTypeDef header;       /**< The message header. */
    uint8_t data[MAX_FDCAN_DATA_LENGTH];/**< The message data payload. */
} FDCAN_Message_t;

/**
 * @brief Structure to hold a complete FDCAN message for transmission.
 */
typedef struct {
    FDCAN_TxHeaderTypeDef header;       /**< The message header for transmission. */
    uint8_t data[MAX_FDCAN_DATA_LENGTH];/**< The message data payload. */
} FDCAN_TxMessage_t;

/**
 * @brief Opaque forward declaration for the subscription object.
 *
 * The concrete definition of `struct FDCAN_Subscription_Internal` is intentionally
 * kept private inside the library implementation (`um_fdcan_lib.c`). Exposing only
 * a forward declaration here makes the subscription handle an opaque type: callers
 * can hold pointers to it but cannot access or manipulate its fields directly.
 *
 * Rationale and usage:
 *  - Callers obtain a subscription handle via `FDCAN_Subscribe()`.
 *  - Callers must release subscriptions with `FDCAN_Unsubscribe()`.
 *  - Keeping the struct private enforces correct usage, allows the library to
 *    protect shared state with mutexes, and prevents accidental races or
 *    memory corruption from user code touching internal fields.
 *
 * @note Do NOT move the full struct definition into this header. Doing so would
 *       remove the encapsulation.
 * @note See FDCAN_SubscriptionHandle_t below for the typedef, and to get the full picture of how this is used.
 */
struct FDCAN_Subscription_Internal;

/**
 * @brief An opaque handle representing a subscription to a specific CAN message ID.
 * The user receives this from FDCAN_Subscribe() and uses it for all other functions.
 *
 * The idea is that the user will have a type where he will be handling a pointer without knowing the internal details.
 *
 * @note We need struct FDCAN_Subscription_Internal* FDCAN_SubscriptionHandle_ instead of  FDCAN_Subscription_Internal* FDCAN_SubscriptionHandle_t for typedef (it just creates an alias so that it is easier to work with those types) because of namespaces in C
 */
typedef struct FDCAN_Subscription_Internal* FDCAN_SubscriptionHandle_t;

/**
 * @brief Defines the target for debug message output.
 */
typedef enum {
    FDCAN_DEBUG_NONE,   /**< No debug output. */
    FDCAN_DEBUG_UART,   /**< Output debug messages via UART. */
    // FDCAN_DEBUG_USB_VCP, /**< (Future) Output debug messages via USB Virtual COM Port. */
} FDCAN_DebugTarget_t;

/**
 * @brief Main FDCAN wrapper object. An instance of this should be created for each
 * FDCAN peripheral in use (e.g., one for FDCAN1, one for FDCAN2).
 */
typedef struct {
    // Hardware & RTOS handles
    FDCAN_HandleTypeDef* hfdcan;
    osThreadId_t processing_thread_handle;
    osMutexId_t subscription_list_mutex;
    osMutexId_t tx_mutex;

    // Debugging
    FDCAN_DebugTarget_t debug_target;
    UART_HandleTypeDef* huart_debug;
    osMutexId_t uart_mutex;
    bool debug_target_initialized;

    // Subscription management
    // Statically allocated array of subscriptions.
    struct FDCAN_Subscription_Internal subscription_list[MAX_SUBSCRIPTIONS_PER_WRAPPER];
    uint32_t subscription_count;

} FDCAN_Wrapper_t;

/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/* Exported functions -------------------------------------------------------------------------------------------------------------------------------------------------*/
/** @defgroup UM_FDCAN_LIB_PUBLIC_FUNCTIONS Public API Functions
 *  @ingroup um_fdcan_lib
 *  @brief Functions intended for direct use by the application.
 *  @{
 */

/**
 * @brief This function is not thread-safe and should be called after initializing the FDCAN periphereal but before starting the RTOS scheduler.
 * Initializes the FDCAN wrapper, its hardware filters, and its processing thread.
 * 
 * @param wrapper Pointer to the FDCAN_Wrapper_t object to initialize.
 * @param hfdcan Pointer to the HAL FDCAN handle (e.g., &hfdcan1).
 * @param std_filters An array of pre-configured FDCAN_FilterTypeDef structures for standard IDs. Can be NULL if std_filter_count is 0.
 * @param std_filter_count The number of filters in the 'std_filters' array.
 * @param ext_filters An array of pre-configured FDCAN_FilterTypeDef structures for extended IDs. Can be NULL if ext_filter_count is 0.
 * @param ext_filter_count The number of filters in the 'ext_filters' array.
 * 
 * @return osOK on success, otherwise an error code.
 *
 * @note The wrapper's debug fields (`debug_target`, `huart_debug`, `uart_mutex`) should be configured *before* calling this function if debug output is desired.
 * @note This function is not thread-safe and should be called after initializing the FDCAN periphereal but before starting the RTOS scheduler.
 * @example
 *
 * // In user's code (e.g. main.c)
 * // Assume huart3 and uart_debug_mutex are initialized elsewhere.
 *
 * // 1. Define the filter configurations
 * FDCAN_FilterTypeDef my_can1_std_filters[2];
 *
 * // Filter 0: Accept a single ID of 0x100
 * my_can1_std_filters[0].IdType = FDCAN_STANDARD_ID;
 * my_can1_std_filters[0].FilterIndex = 0;
 * my_can1_std_filters[0].FilterType = FDCAN_FILTER_DUAL;
 * my_can1_std_filters[0].FilterConfig = FDCAN_FILTER_TO_RX_FIFO0;
 * my_can1_std_filters[0].FilterID1 = 0x100;
 * my_can1_std_filters[0].FilterID2 = 0x100;
 *
 * // Filter 1: Accept a range of IDs from 0x200 to 0x210
 * my_can1_std_filters[1].IdType = FDCAN_STANDARD_ID;
 * my_can1_std_filters[1].FilterIndex = 1; // User must manage the index
 * my_can1_std_filters[1].FilterType = FDCAN_FILTER_RANGE;
 * my_can1_std_filters[1].FilterConfig = FDCAN_FILTER_TO_RX_FIFO0;
 * my_can1_std_filters[1].FilterID1 = 0x200;
 * my_can1_std_filters[1].FilterID2 = 0x210;
 *
 * // 2. Call your wrapper's Init function
 * FDCAN_Wrapper_t can1_wrapper;
 * memset(&can1_wrapper, 0, sizeof(FDCAN_Wrapper_t)); // Good practice to zero-initialize
 * can1_wrapper.debug_target = FDCAN_DEBUG_UART;
 * can1_wrapper.huart_debug = &huart3;
 * can1_wrapper.uart_mutex = uart_debug_mutex;
 *
 * // 3. Call the Init function
 * FDCAN_Wrapper_Init(&can1_wrapper, 
 *                    &hfdcan1,
 *                    my_can1_std_filters, 
 *                    1, 
 *                    NULL,  // No extended filters
 *                    0);
 */
osStatus_t FDCAN_Wrapper_Init(FDCAN_Wrapper_t *wrapper,
                              FDCAN_HandleTypeDef *hfdcan,
                              const FDCAN_FilterTypeDef* std_filters,
                              uint32_t std_filter_count,
                              const FDCAN_FilterTypeDef* ext_filters,
                              uint32_t ext_filter_count);

/**
 * @brief Subscribes to a specific CAN message ID.
 * This creates a dedicated queue for the message and returns a handle to the subscription.
 * @param wrapper Pointer to the initialized FDCAN_Wrapper_t object.
 * @param message_id The CAN message ID to listen for.
 * @return A handle to the subscription, or NULL on failure (e.g., max subscriptions reached).
 */
FDCAN_SubscriptionHandle_t FDCAN_Subscribe(FDCAN_Wrapper_t *wrapper, uint32_t message_id);

/**
 * @brief Unsubscribes and cleans up resources for a given subscription.
 * @param wrapper Pointer to the initialized FDCAN_Wrapper_t object.
 * @param handle The subscription handle that was returned by FDCAN_Subscribe().
 * @return osOK on success, otherwise an error code.
 */
osStatus_t FDCAN_Unsubscribe(FDCAN_Wrapper_t *wrapper, FDCAN_SubscriptionHandle_t handle);

/**
 * @brief Waits to receive a message for a specific subscription. This is a blocking function.
 * @param handle The subscription handle.
 * @param message Pointer to a structure to store the received message.
 * @param timeout The maximum time to wait in milliseconds (or osWaitForever).
 * @return osOK if a message was received, osErrorTimeout if the timeout was reached.
 */
osStatus_t FDCAN_Receive(FDCAN_SubscriptionHandle_t handle, FDCAN_Message_t *message, uint32_t timeout);

/**
 * @brief Transmits an FDCAN message.
 * @param wrapper Pointer to the initialized FDCAN_Wrapper_t object.
 * @param message Pointer to the message to be transmitted.
 * @return osOK on success, otherwise an error code.
 */
osStatus_t FDCAN_Transmit(FDCAN_Wrapper_t *wrapper, const FDCAN_TxMessage_t *message);

/**
 * @brief (For advanced use) Gets the underlying queue from a subscription handle.
 * This allows a single task to wait on multiple subscriptions using a QueueSet.
 * @param handle The subscription handle.
 * @return The osMessageQueueId_t for the subscription, or NULL if the handle is invalid.
 */
osMessageQueueId_t FDCAN_GetQueueFromSubscription(FDCAN_SubscriptionHandle_t handle);

/** @} */ // End of UM_FDCAN_LIB_PUBLIC_FUNCTIONS group


















#endif /* INC_UM_FDCAN_LIB_H_ */
